<title>Eventual Consistency</title>

<meta charset="utf-8">

<link rel="stylesheet" href="../../../style.css">

<link rel="prev" href="why.html">

<link rel="next" href="tour.html">

<script src="../../../script.js"></script>

<h2 id="consistency">最终一致性</h2>

<p>在上一章节中, 我们看到CouchDB的灵活性允许我们可以随着我们应用程序的增长和变化来演进我们的数据. 在这一章节中, 我们会了解如何在我们的应用中, 顺着CouchDB的简单性这一特性来工作, 并且帮助我们自然而然的构建可扩展的, 分布式的系统.

<h3 id="grain">按照套路来工作</h3>

<p>分布式系统是一个可以在一个广泛的网络上健壮工作的系统. 网络计算的一个明显的特点就是网络连接可能会断掉, 而且有多种策略来处理这个网络错误. CouchDB不同于其他的地方在于, 它接受最终一致性, 和把绝对一致性放在资源可用性之前(像关系型数据库管理系统或者Paxos算法)正好相反. 但这些系统的共同之处在于它们都关心当多人同时访问时的数据表现不一致. 它们的实现不同在, 它们在一致性, 可用性或者可分割性上的优先级.

<p>开发分布式系统是不容易的. 许多你会遇到的警告和”gotchas” 不会马上显现. 我们没有全部的解决办法, CouchDB也不是万能药, 但是如果你顺着CouchDB的套路而不是反着它, 那么一条最少阻碍的道路会把你引向自然而然的可扩展的应用.

<p>当然, 构建一个公布式系统只是一个开始. 一个网站, 用着只有一半时间有用的数据库, 基本没有价值. 不幸的是, 传统的关系数据库对于一致性的实现使得它很容易让程序员依赖于全局状态, 全局时钟等, 却没有意识到自己正在这么做. 在检查CouchDB是如何提升可扩展性之前, 我们来看一看一个分布式系统所面临的各种约束. After we’ve seen the problems that arise when parts of your application can’t rely on being in constant contact with each other, we’ll see that CouchDB provides an intuitive and useful way for modeling applications around high-availability.

<h3 id="cap">CAP理论</h3>

<p>CAP理论描述了基于网络的分布式系统的几种不同的策略. CouchDB 的解决方法是使用备份在各个参与节点间同步应用的改变. 这是一个与一致性算法和关系数据库在根本上不同的实现, 它们的不同在于, 一致性, 可用性和可分割性的交叉点.

<p>CAP理论, 如图1所示, 指出了三个明显不同的关心点:

<dl>

<dt>一致性</dt>

<dd>所有的数据库客户端都看到相同的数据, 即使存在并发的更新.</dd>

<dt>可用性</dt>

<dd>所有的数据库客户端总能得到某一版本的数据.</dd>

<dt>可分割性</dt>

<dd>数据库可以被分割在多个服务器上.</dd>

</dl>

<p>选择其中的两个.

<div class="figure" id="figure/1">

<img src="consistency/01.png">

<p class="caption">Figure 1. The CAP theorem

</div>

<p>当一个系统增长到足够大, 大到一个单一的数据库节点不能处理给它的负载前, 一个很显然的办法就是增加更加的服务器. 当我们增加节点, 我们不得不开始考虑, 如何在节点间分割数据. 我们是在这些数据库上放置完全相同的数据? 还是把不同部分的数据放在不同的数据库服务器上? 还是应该只让一些确定的数据库服务来写数据而另外一些则处理读的请求?

<p>不管我们选择哪种实现, 一个我们一直会遇到的问题是保持所有这些数据库服务器的同步. 如果你在一个节点上写了某些数据, 你要如何保证, 一个到另一个数据库服务器的读请求会反映这个最新的信息? 这些事件可能会发生在几毫秒之内. 即使只有少量的数据库服务器集, 这个问题也是相当复杂的.

<p>当所有客户端都看到数据库的同一视图这一点非常重要的时候, 一个节点的用户在读和写数据库之前, 不得不等待其他节点的用户的同意. 在这个例子中, 我们可以看到, 可用性比一致性更加不重要. 然而, 也有可用性比一致性来的重要的状况.

<blockquote>

<p>“Each node in a system should be able to make decisions purely based on local state. If you need to do something under high load with failures occurring and you need to reach agreement, you’re lost… If you’re concerned about scalability, any algorithm that forces you to run agreement will eventually become your bottleneck. Take that as a given.”
</blockquote>

<p class="attribution">— Werner Vogels, Amazon CTO and Vice President

<p>如果把可用性优先来考虑, 我们可以让客户端在不等待其他节点同意的情况下就把数据写入一个数据库节点. 如果数据库知道在这些操作后, 如何保持数据库节点间的一致性, 那么我们就达到了一种”最终一致性”, 以此为交换, 得到了高可用性. 对于很多应用来说, 这是一个相当可接受的交易.

<p>不像关系数据库, 每一个操作都会导致整个数据库层面的一致性检查, CouchDB让构建那些以牺牲限时一致性来换取巨大的性能提升的应用变得简单.

<h3 id="local">本地一致性</h3>

<p>在我们去了解CouchDB是如何在集群上工作之前, 理解单一CouchDB节点的内部工作原理很重要. CouchDB API 的设计提供了一个方便的, 但是瘦小的, 封装的数据库核心. 通过仔细的了解数据库核心结构, 我们会对它的API有一个更好的理解.

<h4 id="key">数据的钥匙</h4>

<p>在CouchDB的核心, 是一个强大的B-Tree存储引擎. 一个 B-Tree 是一个经过排序的数据结构, 它允许搜索, 插入和删除(in logarithmic time). 如图2所示, CouchDB的所有内部数据, 文档和视图都使用这个B-Tree存储引擎. 如果我们明白了其中一个, 我们就明白了全部.

<div class="figure" id="figure/2">

<img src="consistency/02.png">

<p class="caption">Figure 2. Anatomy of a view request

</div>

<p>CouchDB使用 MapReduce 来计算一个视图的结果. MapReduce用了两个过程, “map”和”reduce”, 它们被独立的用于每个文档. 可以独立的进行这些操作意味着视图计算本身可以是平行的和增量的. 更加重要的是, 因为这些过程会产生 key/value 对, CouchDB就可以把它们插入到B-Tree引擎中, 并以key来排序. 在B-Tree中, 通过key, 或者key范围来查找, 效率非常高, 用大O表示法来描述的话分别是, O(log N) 和 O(log N + K). 

<p>在CouchDB里, 我们通过key或者key范围来得到文档和视图. 这是基于CouchDB的B-Tree引擎操作的一种直接映射. 和文档插入与更新一起, 这种直接映射是我们把CouchDB API描述成一个数据库核心的轻量的封装的原因.

<p>可以通过单独的key来得到结果是一个非常重要的限制, 因为它允许我们得到巨大的性能提升. 还有巨大的速度提升, 我们可以把我们的数据分割到多个节点, 但却不会影响到每个节点独立查找数据的能力. BigTable, Hadoop, SimpleDB, 还有memcached限制通过key来查找对象也是因为这些原因.

<h4 id="locking">无锁的</h4>

<p>关系数据库里的一张表是一个单一的数据结构. 如果你想要修改一张表, 比如更新一行, 数据库系统必须保证没有其他正在更新那一行并且没有人可以读正在更新的这一行. 处理这种情况的一般方法就是所谓的锁机制. 如果多个客户端想到用这张表, 第一个客户端会得到一个锁, 这会让其他人全部等待. 当第一个客户端处理完成后, 下一个得到许可, 其他人继续等待, 如此往下. 这种顺序的请求处理方式, 即使是在它们同时到达的时候, 也会浪费掉你服务的相当可观的处理能力. 在高负载下, 一个关系数据库可能会把更多的时候花费在, 谁被允许干什么事, 是以怎样一个顺序, 而大于真正要做的事情的时间.

<p>作为锁机制的代替, CouchDB使用了多版本并发控制(MVCC)来管理对于数据库的关发请求. 图3形象描述了MVCC和传统锁机制的不同. MVCC意味着可以一直, 甚至在高负载的情况下全速运行. 请求平行的被处理, 榨干你机器提供的最终一滴处理能力.

<div class="figure" id="figure/3">

<img src="consistency/03.png">

<p class="caption">Figure 3. MVCC means no locking

</div>

<p>CouchDB里的文档有版本的, 很像一个常规的版本控制系统, 比如Subversion. 如果你想改变一个文档的value, 你会创建一个全新的文档, 然后保存在原来的文档之上. 这么做了之后, 你等于有一个同一文档的两个版本, 一个老的和一个新的.

<p>这种方式与锁机制比改进在哪里呢? 考虑下这种情况, 一堆请求想要同一个文档. 第一个请求读这个文档. 当这个请求正在被处理时, 第二个请求改变了这个方法. 因为第二个请求包含了一个全新版本的文档, CouchDB可以简单的把它附加到数据库, 而不用等待那个读请求结束. 

<p>当第三个请求想要读这个文档时, CouchDB会把它指向一个那个被写入的新版本. 在这整个过程中, 第一个请求可以仍旧在读那个原始的版本.

<p>一个读请求总是会看到最近的数据库快照.

<h4 id="validation">验证</h4>

<p>作为应用开发者, 我们必须要考虑哪些请求我们是接受的, 哪些是要拒绝的. 在传统关系数据库中, 对复杂数据作这种有效的验证的能力, 很有诱惑力. 幸运的是, CouchDB提供了一种强大的方法, 可以在数据库中做预文档的验证.

<p>CouchDB可以使用类似于那些用于MapReduce的JavaScript方法来验证文档. 每当你试图去修改一个文档, CouchDB会传给验证方法一个现存文档的副本, 一个新文档的副本, 和一个附加信息的集合, 比如用户认证细节. 然后, 验证方法可以来通过或者拒绝这个更新.

<p>顺着这种套路, 让CouchDB帮你做这些工作, 我们为自己节省了极大的CPU时间, 这些时间原本会被用在, 从SQL顺序化对象图表, 把它们转化成域对象, 然后使用这些对象做应用层的验证

<h3 id="distributed">分布一致性</h3>

<p>保持单一数据库节点的一致性对于大多数数据库来说都相对简单. 当你试图在多个数据库数据库之前保持一致性时, 真正的问题开始浮现. 如果一个客户端在服务器A上做了一个写操作, 我们怎么样才能保证它和服务器B, C或者D保持一致? 对于关系数据库来说, 这是一个非常复杂的问题, 可以用一整本书来阐述它的解决办法. 你可以使用多multi-master, master/slave, partitioning, sharding, write-through caches, 和其他的复杂的技术.

<h4 id="incremental">增量备份</h4>

<p>因为CouchDB操作是在一个单一文档的上下文中进行的, 如果你想要使用两个数据库节点, 你不需要去担心它们正处于实时通讯中. CouchDB通过增量备份, 一个在各个服务器之间周期性的复制文档变化的过程, 来实现这种最终一致性. 我们可以建立那种有名的shared nothing数据库集群, 在那里每个节点是独立并且自我满足的, 不会有系统级的竞争.

<p>想要扩展你的CouchDB数据库集群? 只要扔进另外一个服务器就行了.

<p>如图4所示, 使用CouchDB的增量备份, 你可以用任何你喜欢的方式, 任何你喜欢的时间, 在任意两个数据库之间同步你的数据. 备份完成后, 每个数据库都可以独立工作.

<p>你可以使用这个特性,在一个集群或者数据中心之间, 用像cron这样的工作排程来同步数据库, 或者你也可以用它把数据同步到你的笔记本, 然后再旅行的时候作离线工作使用. 每个数据库都可以像平常那样使用而且数据库间的变化可以在以后双向同步.

<div class="figure" id="figure/4">

<img src="consistency/04.png">

<p class="caption">Figure 4. Incremental replication between CouchDB nodes

</div>

<p>如果你在两个数据库中改变了同一个文档并且想要同步它们, 怎么办? CouchDB的备份系统拥有自动的冲突检测和解决方法. 当CouchDB发现两个数据库中的文档都被改变了, 它把这个文档标记成冲突状态, 很像一个常规的版本控制系统所做的那样.

<p>这个问题不像第一次听起来那样麻烦. 如果在备份中有一个文档的两个版本冲突了, 胜出的版本是那个在文档历史中最近被保存的那个版本. 不像你可能想像的那样, 把输了的那个版本丢弃, CouchDB把这个版本在文档历史中保存为上一个版本, 这样如果你需要的话就可以得到它. 这是自动和实时的, 所以两个数据库会作出完全相同的选择.

<p>对于你的应用如何处理冲突更好取决于你自己. 你可以按默认的解决冲突, 也可以把文档版本转而更老的那个, 或者试着把两个版本合并然后存储这个结果.

<h4 id="study>案例分析</h4>

<p>Greg Borenstein, 我们的一个朋友和同事, 写了一个库用来把Songbird播放列表转化成JSON对象, 并决定把它们存储到CouchDB中, 作为一个备份应用的一部分. 整个软件使用了CouchDB的MVCC和文档版本来保证Songbird播放列表在节点间健壮的被备份.

<p>Songbird is a free software media player with an integrated web browser, based on the Mozilla XULRunner platform. Songbird is available for Microsoft Windows, Apple Mac OS X, Solaris, and Linux.

<p>让我们来看一下Songbird备份应用的整个工作流程, 首先一个用户从一个单一的计算机备份了播放列表, 然后用Songbird在多个计算机之间同步播放列表. 我们可以看到文档版本如何把一个麻烦的问题变成一件自然而然的事情.

<p>第一次我们使用备份程序时, 我们导入我们的播放列表然后初始化一个备份. 每个播放列表被转化成一个JSON对象然后提交给CouchDB数据库. 如图5所示, CouchDB返回保存到数据库的每个播放列表文档的ID和版本号.

<div class="figure" id="figure/5">

<img src="consistency/05.png">

<p class="caption">Figure 5. Backing up to a single database

</div>

<p>几天以后, 我们发现我们的播放列表已经更新了, 我们想要备份这些改变. 在我们把播放列表导入到备份程序后, 它会去CouchDB取最新的版本, 同时能到相应的文档版本. 当应用程序提交新播放列表文档时, CouchDB接受这个文档, 而文档的版本已经包含在请求中了. 

<p>然后, CouchDB会保证请求里提交给它的文档版本和数据库里保存的文档版本一致. 因为CouchDB在每个修改后都会更新版本, 如果这两个版本不同步, 这说明有人在我们请求这个文档和发送我们的更新之间, 对这个文档做了改变. 当有人改变文档后, 不首先检查这些改变就去改变这个文档通常会是个坏主意.

<p>强制要求客户端返回正确的文档版本是CouchDB乐观并发的中心.

<p>我们有一个笔记本, 我们想要和我们的桌面计算机同步. 为了同步我们在桌面计算机上的所有播放列表, 第一步是在我们的笔记本上选择”从备份恢复”. 这是我们第一次做, 所以做完后我们应该会得到和我们的桌面计算机播放列表完全一个的一个副本.

<p>当在笔记本上编辑了Argentine Tango这个播放列表, 增加了一些我们买的新歌之后, 我们想要保存这些改变. 备份程序在笔记本上的CouchDB数据库中替代掉播放列表文档, 一个新文档版本产生了. 几天后我们想起了这些新歌, 想要把播放列表复制到桌面计算机. 如图6所示, 备份程序统计复制新文档和新版本到桌面计算机的CouchDB数据库. 现在两个CouchDB数据库都有相同的版本号.

<div class="figure" id="figure/6">

<img src="consistency/06.png">

<p class="caption">Figure 6. Synchronizing between two databases

</div>

<p>因为CouchDB跟踪文档版本号, 它保证像这样的更新只会在基于当前信息的基础上才会工作. 如果我们在同步过程之中, 对播放列表备份文档作出了改变, 事情就不会那么顺利了.

<p>我们在笔记本上备份了一些改变然后忘记同步了. 几天后, 我们在桌面计算机上编辑了我们的播放列表, 做了个备份, 然后想要和我们的笔记本同步了. 如图7所示, 当我们的应用程序想要在两个数据库之间备份时, CouchDB发现从桌面计算机上发来的文档是经过改变的, 然后告诉我们有一个冲突存在.

<p>从应用层的观点来看, 从这个错误里恢复很容易做到. 只要下载CouchDB播放列表的版本, 然后可以合并这些改变或者在一个新的播放列表里存储本地改变.

<div class="figure" id="figure/7">

<img src="consistency/07.png">

<p class="caption">Figure 7. Synchronization conflicts between two databases

</div>

<h3 id="wrap">收尾</h3>

<p>CouchDB的设计从Web架构里借用了很多东西, 并且从在Web架构上部署大型分布式系统中学到了很多. 通过理解为什么这种架构可以按照它的方式运行, 通过学习观察你应用程序的哪些部分容易做分布, 哪些部分不容易, 你将增强你设计分布式的和可扩展的应用程序的能力––––使用CouchDB或者不使用它.

<p>我们已经了解了CouchDB一致性模型的主要议题, 并提示了顺着CouchDB工作而不是逆着它得到的好处. 但是, 理论已经足够了, 让我们起来看看所有这些到底是什么.
